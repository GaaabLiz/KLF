<?xml version="1.0" encoding="UTF-8"?>
<issues format="6" by="lint 8.0.2" type="baseline" client="gradle" dependencies="false" name="AGP (8.0.2)" variant="all" version="8.0.2">

    <issue
        id="LintError"
        message="Unexpected failure during lint analysis of Autofill.kt (this is a bug in lint or one of the libraries it depends on)&#xA;&#xA;Message: Exception occurred when reading Kotlin metadata&#xA;&#xA;The crash seems to involve the detector `androidx.compose.ui.lint.ModifierDeclarationDetector`.&#xA;You can try disabling it with something like this:&#xA;    android {&#xA;        lint {&#xA;            disable &quot;ModifierFactoryExtensionFunction&quot;, &quot;ModifierFactoryReturnType&quot;, &quot;ModifierFactoryUnreferencedReceiver&quot;&#xA;        }&#xA;    }&#xA;&#xA;Stack: `InconsistentKotlinMetadataException:KotlinClassMetadata$Companion.read(KotlinClassMetadata.kt:721)←KotlinMetadataUtilsKt.getKmDeclarationContainer(KotlinMetadataUtils.kt:56)←KotlinMetadataUtilsKt.toKmFunction(KotlinMetadataUtils.kt:39)←ModifierDeclarationDetectorKt$ensureReceiverIsReferenced$1.visitCallExpression(ModifierDeclarationDetector.kt:253)←KotlinUFunctionCallExpression.accept(KotlinUFunctionCallExpression.kt:165)←UReturnExpression$DefaultImpls.accept(UReturnExpression.kt:22)←KotlinUImplicitReturnExpression.accept(KotlinUImplicitReturnExpression.kt:12)←ImplementationUtilsKt.acceptList(implementationUtils.kt:15)←UBlockExpression$DefaultImpls.accept(UBlockExpression.kt:21)←KotlinLazyUBlockExpression.accept(KotlinLazyUBlockExpression.kt:10)←UMethod$DefaultImpls.accept(UMethod.kt:45)←KotlinUMethod.accept(KotlinUMethod.kt:18)←ModifierDeclarationDetectorKt.ensureReceiverIsReferenced(ModifierDeclarationDetector.kt:230)←ModifierDeclarationDetectorKt.checkReceiver(ModifierDeclarationDetector.kt:219)←ModifierDeclarationDetectorKt.access$checkReceiver(ModifierDeclarationDetector.kt:1)←ModifierDeclarationDetector$createUastHandler$1.visitMethod(ModifierDeclarationDetector.kt:106)←UElementVisitor$DispatchPsiVisitor.visitMethod(UElementVisitor.kt:763)←UElementVisitor$DelegatingPsiVisitor.visitMethod(UElementVisitor.kt:1132)←UMethod$DefaultImpls.accept(UMethod.kt:42)←KotlinUMethod.accept(KotlinUMethod.kt:18)←ImplementationUtilsKt.acceptList(implementationUtils.kt:15)←AbstractKotlinUClass.accept(AbstractKotlinUClass.kt:46)←ImplementationUtilsKt.acceptList(implementationUtils.kt:15)←UFile$DefaultImpls.accept(UFile.kt:91)←KotlinUFile.accept(KotlinUFile.kt:15)←UastLintUtilsKt.acceptSourceFile(UastLintUtils.kt:679)←UElementVisitor$visitFile$3.run(UElementVisitor.kt:274)←LintClient.runReadAction(LintClient.kt:1820)←LintDriver$LintClientWrapper.runReadAction(LintDriver.kt:2828)←UElementVisitor.visitFile(UElementVisitor.kt:271)←LintDriver$visitUastDetectors$1.run(LintDriver.kt:2113)←LintClient.runReadAction(LintClient.kt:1820)←LintDriver$LintClientWrapper.runReadAction(LintDriver.kt:2828)←LintDriver.visitUastDetectors(LintDriver.kt:2113)←LintDriver.visitUast(LintDriver.kt:2072)←LintDriver.runFileDetectors(LintDriver.kt:1434)←LintDriver.checkProject(LintDriver.kt:1197)←LintDriver.checkProjectRoot(LintDriver.kt:657)←LintDriver.access$checkProjectRoot(LintDriver.kt:166)←LintDriver$analyzeOnly$1.invoke(LintDriver.kt:470)←LintDriver$analyzeOnly$1.invoke(LintDriver.kt:463)←LintDriver.doAnalyze(LintDriver.kt:530)←LintDriver.analyzeOnly(LintDriver.kt:463)←LintCliClient$analyzeOnly$1.invoke(LintCliClient.kt:247)←LintCliClient$analyzeOnly$1.invoke(LintCliClient.kt:247)←LintCliClient.run(LintCliClient.kt:289)←LintCliClient.run$default(LintCliClient.kt:272)←LintCliClient.analyzeOnly(LintCliClient.kt:247)←Main.run(Main.java:1668)←Main.run(Main.java:274)←GeneratedMethodAccessor1097.invoke(null:-1)←DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)←Method.invoke(Method.java:568)←AndroidLintWorkAction.invokeLintMainRunMethod(AndroidLintWorkAction.kt:98)←AndroidLintWorkAction.runLint(AndroidLintWorkAction.kt:87)←AndroidLintWorkAction.execute(AndroidLintWorkAction.kt:62)←DefaultWorkerServer.execute(DefaultWorkerServer.java:63)←NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)←NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)←ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)←NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)←AbstractWorker$1.call(AbstractWorker.java:44)←AbstractWorker$1.call(AbstractWorker.java:41)←DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204)←DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199)←DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66)←DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59)←DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157)←DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59)←DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53)←DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73)←AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)←NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)←DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:169)←FutureTask.run(FutureTask.java:264)←DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:187)←DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:120)←DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:162)←Factories$1.create(Factories.java:31)←DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:249)←DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:109)←DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:114)←DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:157)←DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:126)←Executors$RunnableAdapter.call(Executors.java:539)←FutureTask.run(FutureTask.java:264)←ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)←ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:49)←ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)←ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)←Thread.run(Thread.java:840)`&#xA;&#xA;You can run with --stacktrace or set environment variable `LINT_PRINT_STACKTRACE=true` to dump a full stacktrace to stdout.">
        <location
            file="src/androidMain/kotlin/io/github/gaaabliz/kliz/compose/android/ui/utils/Autofill.kt"/>
    </issue>

    <issue
        id="ObsoleteLintCustomCheck"
        message="Library lint checks reference invalid APIs; these checks **will be skipped**!&#xA;&#xA;Lint found an issue registry (`androidx.compose.runtime.lint.RuntimeIssueRegistry`)&#xA;which contains some references to invalid API:&#xA;org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenFactory: void afterLeavingAnalysisContext(org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken)&#xA;(Referenced from androidx/compose/runtime/lint/AutoboxingStateCreationDetector.class)&#xA;&#xA;Therefore, this lint check library is **not** included&#xA;in analysis. This affects the following lint checks:&#xA;`AutoboxingStateValueProperty`&#xA;`AutoboxingStateCreation`&#xA;`CoroutineCreationDuringComposition`&#xA;`FlowOperatorInvokedInComposition`&#xA;`ComposableLambdaParameterNaming`&#xA;`ComposableLambdaParameterPosition`&#xA;`ComposableNaming`&#xA;`StateFlowValueCalledInComposition`&#xA;`CompositionLocalNaming`&#xA;`MutableCollectionMutableState`&#xA;`ProduceStateDoesNotAssignValue`&#xA;`RememberReturnType`&#xA;`OpaqueUnitKey`&#xA;`UnrememberedMutableState`&#xA;&#xA;To use this lint check, upgrade to a more recent version&#xA;of the library.">
        <location
            file="$GRADLE_USER_HOME/caches/transforms-3/356fa3e6a6a253ef231168381afad12b/transformed/runtime-release/jars/lint.jar"/>
    </issue>

</issues>
